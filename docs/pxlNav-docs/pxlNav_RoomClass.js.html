<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>pxlNav/RoomClass.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://procstack.github.io/Outlet.htm" target="_blank" class="menu-item" id="pxlNav_Example" >pxlNav Example : The Outlet</a></h2><h3>Global</h3><ul><li><a href="global.html##pxlEnums">#pxlEnums</a></li><li><a href="global.html#pxlOptions">pxlOptions</a></li><li><a href="global.html#pxlUserSettings">pxlUserSettings</a></li></ul><h3>Modules</h3><ul><li><a href="module-pxlNav.html">pxlNav</a></li><li><a href="pxlNav.module_pxlEffects.html">pxlNav.pxlEffects</a></li><li><a href="pxlNav.pxlEffects.module_pxlParticles.html">pxlNav.pxlEffects.pxlParticles</a></li></ul><h3>Classes</h3><ul><li><a href="pxlAnim.html">pxlAnim</a><ul class='methods'><li data-type='method'><a href="pxlAnim.html#.Animation#addClips">Animation#addClips</a></li><li data-type='method'><a href="pxlAnim.html#.Animation#destroy">Animation#destroy</a></li><li data-type='method'><a href="pxlAnim.html#.Animation#getMesh">Animation#getMesh</a></li><li data-type='method'><a href="pxlAnim.html#.Animation#getMixer">Animation#getMixer</a></li><li data-type='method'><a href="pxlAnim.html#.Animation#getRig">Animation#getRig</a></li><li data-type='method'><a href="pxlAnim.html#.Animation#hasClip">Animation#hasClip</a></li><li data-type='method'><a href="pxlAnim.html#.Animation#initObject">Animation#initObject</a></li><li data-type='method'><a href="pxlAnim.html#.Animation#playClip">Animation#playClip</a></li><li data-type='method'><a href="pxlAnim.html#.Animation#setStateConnections">Animation#setStateConnections</a></li><li data-type='method'><a href="pxlAnim.html#.Animation#setWeight">Animation#setWeight</a></li></ul></li><li><a href="pxlCamera.html">pxlCamera</a><ul class='methods'><li data-type='method'><a href="pxlCamera.html#.Camera#setCameraRotateEasing">Camera#setCameraRotateEasing</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setGravityMax">Camera#setGravityMax</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setGravityRate">Camera#setGravityRate</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setInputMovementMult">Camera#setInputMovementMult</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setJumpHoldMax">Camera#setJumpHoldMax</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setJumpImpulse">Camera#setJumpImpulse</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setJumpRepeatDelay">Camera#setJumpRepeatDelay</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setJumpScalar">Camera#setJumpScalar</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setMaxStepHeight">Camera#setMaxStepHeight</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setMovementEase">Camera#setMovementEase</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setMovementMax">Camera#setMovementMax</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setMovementScalar">Camera#setMovementScalar</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setPositionBlend">Camera#setPositionBlend</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setTouchSensitivity">Camera#setTouchSensitivity</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setUserHeight">Camera#setUserHeight</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setUserScale">Camera#setUserScale</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setUserSettings">Camera#setUserSettings</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setWalkBounceEaseIn">Camera#setWalkBounceEaseIn</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setWalkBounceEaseOut">Camera#setWalkBounceEaseOut</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setWalkBounceHeight">Camera#setWalkBounceHeight</a></li><li data-type='method'><a href="pxlCamera.html#.Camera#setWalkBounceRate">Camera#setWalkBounceRate</a></li></ul></li><li><a href="pxlColliders.html">pxlColliders</a><ul class='methods'><li data-type='method'><a href="pxlColliders.html#.buildHelper">buildHelper</a></li><li data-type='method'><a href="pxlColliders.html#.castGravityRay">castGravityRay</a></li><li data-type='method'><a href="pxlColliders.html#.castInteractRay">castInteractRay</a></li><li data-type='method'><a href="pxlColliders.html#.castRay">castRay</a></li><li data-type='method'><a href="pxlColliders.html#.prepColliders">prepColliders</a></li><li data-type='method'><a href="pxlColliders.html#.prepInteractables">prepInteractables</a></li><li data-type='method'><a href="pxlColliders.html#.setHelperActiveFace">setHelperActiveFace</a></li><li data-type='method'><a href="pxlColliders.html#.stepHelper">stepHelper</a></li></ul></li><li><a href="pxlCookie.html">pxlCookie</a><ul class='methods'><li data-type='method'><a href="pxlCookie.html#.addDictionary">addDictionary</a></li><li data-type='method'><a href="pxlCookie.html#.clearCookie">clearCookie</a></li><li data-type='method'><a href="pxlCookie.html#.evalCookie">evalCookie</a></li><li data-type='method'><a href="pxlCookie.html#.getClearCookieRegexp">getClearCookieRegexp</a></li><li data-type='method'><a href="pxlCookie.html#.getExpiration">getExpiration</a></li><li data-type='method'><a href="pxlCookie.html#.getRegexp">getRegexp</a></li><li data-type='method'><a href="pxlCookie.html#.hasCookie">hasCookie</a></li><li data-type='method'><a href="pxlCookie.html#.isEqual">isEqual</a></li><li data-type='method'><a href="pxlCookie.html#.parseCookie">parseCookie</a></li><li data-type='method'><a href="pxlCookie.html#.parseDict">parseDict</a></li><li data-type='method'><a href="pxlCookie.html#.pullData">pullData</a></li><li data-type='method'><a href="pxlCookie.html#.readCookie">readCookie</a></li><li data-type='method'><a href="pxlCookie.html#.setCookie">setCookie</a></li><li data-type='method'><a href="pxlCookie.html#.valueToString">valueToString</a></li><li data-type='method'><a href="pxlCookie.html#.variableToString">variableToString</a></li></ul></li><li><a href="pxlEnums.html">pxlEnums</a><ul class='methods'><li data-type='method'><a href="pxlEnums.html#.ANTI_ALIASING">ANTI_ALIASING</a></li><li data-type='method'><a href="pxlEnums.html#.CAMERA_EVENT">CAMERA_EVENT</a></li><li data-type='method'><a href="pxlEnums.html#.COLLIDER_TYPE">COLLIDER_TYPE</a></li><li data-type='method'><a href="pxlEnums.html#.COLOR_SHIFT">COLOR_SHIFT</a></li><li data-type='method'><a href="pxlEnums.html#.DEVICE_ACTION">DEVICE_ACTION</a></li><li data-type='method'><a href="pxlEnums.html#.DEVICE_EVENT">DEVICE_EVENT</a></li><li data-type='method'><a href="pxlEnums.html#.DEVICE_TYPE">DEVICE_TYPE</a></li><li data-type='method'><a href="pxlEnums.html#.FILE_TYPE">FILE_TYPE</a></li><li data-type='method'><a href="pxlEnums.html#.GEOMETRY_SIDE">GEOMETRY_SIDE</a></li><li data-type='method'><a href="pxlEnums.html#.HUD_ACTION">HUD_ACTION</a></li><li data-type='method'><a href="pxlEnums.html#.HUD_ELEMENT">HUD_ELEMENT</a></li><li data-type='method'><a href="pxlEnums.html#.RENDER_LAYER">RENDER_LAYER</a></li><li data-type='method'><a href="pxlEnums.html#.SHADOW_MAP">SHADOW_MAP</a></li><li data-type='method'><a href="pxlEnums.html#.SKY_HAZE">SKY_HAZE</a></li><li data-type='method'><a href="pxlEnums.html#.USER_SPEED">USER_SPEED</a></li><li data-type='method'><a href="pxlEnums.html#.VERBOSE_LEVEL">VERBOSE_LEVEL</a></li></ul></li><li><a href="pxlHUD.html">pxlHUD</a><ul class='methods'><li data-type='method'><a href="pxlHUD.html#.HUD#addItem">HUD#addItem</a></li><li data-type='method'><a href="pxlHUD.html#.HUD#addToHUD">HUD#addToHUD</a></li><li data-type='method'><a href="pxlHUD.html#.HUD#createButton">HUD#createButton</a></li><li data-type='method'><a href="pxlHUD.html#.HUD#createDragRegion">HUD#createDragRegion</a></li><li data-type='method'><a href="pxlHUD.html#.HUD#createImage">HUD#createImage</a></li><li data-type='method'><a href="pxlHUD.html#.HUD#createRegion">HUD#createRegion</a></li><li data-type='method'><a href="pxlHUD.html#.HUD#createSlider">HUD#createSlider</a></li><li data-type='method'><a href="pxlHUD.html#.HUD#createText">HUD#createText</a></li><li data-type='method'><a href="pxlHUD.html#.HUD#createThumbstick">HUD#createThumbstick</a></li><li data-type='method'><a href="pxlHUD.html#.HUD#emit">HUD#emit</a></li><li data-type='method'><a href="pxlHUD.html#.HUD#subscribe">HUD#subscribe</a></li></ul></li><li><a href="pxlParticles_BillowSmoke.html">pxlParticles/BillowSmoke</a><ul class='methods'><li data-type='method'><a href="pxlParticles_BillowSmoke.html#.BillowSmoke#build">BillowSmoke#build</a></li></ul></li><li><a href="pxlParticles_EmberWisps.html">pxlParticles/EmberWisps</a><ul class='methods'><li data-type='method'><a href="pxlParticles_EmberWisps.html#.EmberWisps#build">EmberWisps#build</a></li></ul></li><li><a href="pxlParticles_FloatingDust.html">pxlParticles/FloatingDust</a><ul class='methods'><li data-type='method'><a href="pxlParticles_FloatingDust.html#.FloatingDust#build">FloatingDust#build</a></li></ul></li><li><a href="pxlParticles_HeightMap.html">pxlParticles/HeightMap</a><ul class='methods'><li data-type='method'><a href="pxlParticles_HeightMap.html#.HeightMap#build">HeightMap#build</a></li><li data-type='method'><a href="pxlParticles_HeightMap.html#.HeightMap#setHeightMapPath">HeightMap#setHeightMapPath</a></li><li data-type='method'><a href="pxlParticles_HeightMap.html#.HeightMap#setSpawnMapPath">HeightMap#setSpawnMapPath</a></li></ul></li><li><a href="pxlParticles_ParticleBase.html">pxlParticles/ParticleBase</a><ul class='methods'><li data-type='method'><a href="pxlParticles_ParticleBase.html#.ParticleBase#addToScene">ParticleBase#addToScene</a></li><li data-type='method'><a href="pxlParticles_ParticleBase.html#.ParticleBase#atlasArrayPicker">ParticleBase#atlasArrayPicker</a></li><li data-type='method'><a href="pxlParticles_ParticleBase.html#.ParticleBase#atlasRandomGen">ParticleBase#atlasRandomGen</a></li><li data-type='method'><a href="pxlParticles_ParticleBase.html#.ParticleBase#atlasRandomList">ParticleBase#atlasRandomList</a></li><li data-type='method'><a href="pxlParticles_ParticleBase.html#.ParticleBase#dupeArray">ParticleBase#dupeArray</a></li><li data-type='method'><a href="pxlParticles_ParticleBase.html#.ParticleBase#elementDuplicator">ParticleBase#elementDuplicator</a></li><li data-type='method'><a href="pxlParticles_ParticleBase.html#.ParticleBase#getSettings">ParticleBase#getSettings</a></li><li data-type='method'><a href="pxlParticles_ParticleBase.html#.ParticleBase#hasPointLights">ParticleBase#hasPointLights</a></li><li data-type='method'><a href="pxlParticles_ParticleBase.html#.ParticleBase#newMaterial">ParticleBase#newMaterial</a></li><li data-type='method'><a href="pxlParticles_ParticleBase.html#.ParticleBase#setAtlasPath">ParticleBase#setAtlasPath</a></li><li data-type='method'><a href="pxlParticles_ParticleBase.html#.ParticleBase#setPosition">ParticleBase#setPosition</a></li></ul></li><li><a href="pxlRoom%2520RoomEnvironment.html">pxlRoom RoomEnvironment</a><ul class='methods'><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#addColliderHelper">addColliderHelper</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#animPostLoad">animPostLoad</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#applyRoomPass">applyRoomPass</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#build">build</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#castRay">castRay</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#cleanupPortalRender">cleanupPortalRender</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#fbxPostLoad">fbxPostLoad</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#getArtistInfo">getArtistInfo</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#getColliders">getColliders</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#getCurrentShader">getCurrentShader</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#getLerpAvgRate">getLerpAvgRate</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#getLerpRate">getLerpRate</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#getName">getName</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#getShaderList">getShaderList</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#hasColliderType">hasColliderType</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#hasColliders">hasColliders</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#hitColliders">hitColliders</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#init">init</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#onMessage">onMessage</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#prepPortalRender">prepPortalRender</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#readShader">readShader</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#resetCamera">resetCamera</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#resize">resize</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#setDependencies">setDependencies</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#setFog">setFog</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#setPortalTexture">setPortalTexture</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#setShader">setShader</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#setUserHeight">setUserHeight</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#start">start</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#step">step</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#stepColliderHelper">stepColliderHelper</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#stop">stop</a></li><li data-type='method'><a href="pxlRoom%252520RoomEnvironment.html#toCameraPos">toCameraPos</a></li></ul></li><li><a href="pxlTimer.html">pxlTimer</a><ul class='methods'><li data-type='method'><a href="pxlTimer.html#.getLerpAvgRate">getLerpAvgRate</a></li><li data-type='method'><a href="pxlTimer.html#.getLerpRate">getLerpRate</a></li><li data-type='method'><a href="pxlTimer.html#.pause">pause</a></li><li data-type='method'><a href="pxlTimer.html#.play">play</a></li><li data-type='method'><a href="pxlTimer.html#.scaleTime">scaleTime</a></li><li data-type='method'><a href="pxlTimer.html#.start">start</a></li><li data-type='method'><a href="pxlTimer.html#.step">step</a></li><li data-type='method'><a href="pxlTimer.html#.stop">stop</a></li><li data-type='method'><a href="pxlTimer.html#.toggleMSLog">toggleMSLog</a></li></ul></li><li><a href="pxlUtils.html">pxlUtils</a><ul class='methods'><li data-type='method'><a href="pxlUtils.html#.Utils#applyTransformList">Utils#applyTransformList</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#arrayToStr">Utils#arrayToStr</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#checkInt">Utils#checkInt</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#cleanBasic">Utils#cleanBasic</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#cleanStrict">Utils#cleanStrict</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#cleanString">Utils#cleanString</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#colorToLinear">Utils#colorToLinear</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#colorTosRGB">Utils#colorTosRGB</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#componentToHex">Utils#componentToHex</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#convertColor">Utils#convertColor</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#copyRoomUrl">Utils#copyRoomUrl</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#degToRad">Utils#degToRad</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#dupeArray">Utils#dupeArray</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#flattenArrayToStr">Utils#flattenArrayToStr</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#gammaCorrectColor">Utils#gammaCorrectColor</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#gammaCorrection">Utils#gammaCorrection</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#getCanvasTexture">Utils#getCanvasTexture</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#getDateTime">Utils#getDateTime</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#getRandom">Utils#getRandom</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#getVideoTexture">Utils#getVideoTexture</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#hexToRgb">Utils#hexToRgb</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#loadTexture">Utils#loadTexture</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#randomFloat">Utils#randomFloat</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#randomizeArray">Utils#randomizeArray</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#rgbToHex">Utils#rgbToHex</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#screenToNDC">Utils#screenToNDC</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#stringToRgb">Utils#stringToRgb</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#toHundreths">Utils#toHundreths</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#toLinear">Utils#toLinear</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#toNearestStr">Utils#toNearestStr</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#toTenths">Utils#toTenths</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#tosRGB">Utils#tosRGB</a></li><li data-type='method'><a href="pxlUtils.html#.Utils#updateUrl">Utils#updateUrl</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="pxlAudio.html">pxlAudio</a></li><li><a href="pxlAutoCam.html">pxlAutoCam</a><ul class='methods'><li data-type='method'><a href="pxlAutoCam.html#.step">step</a></li><li data-type='method'><a href="pxlAutoCam.html#.stepDroneCam">stepDroneCam</a></li><li data-type='method'><a href="pxlAutoCam.html#.toggleAutoCam">toggleAutoCam</a></li></ul></li><li><a href="pxlDevice.html">pxlDevice</a></li><li><a href="pxlEnv.html">pxlEnv</a></li><li><a href="pxlFile.html">pxlFile</a></li><li><a href="pxlGuiDraws.html">pxlGuiDraws</a></li><li><a href="pxlQuality.html">pxlQuality</a></li><li><a href="pxlRendering.html">pxlRendering</a><ul class='methods'><li data-type='method'><a href="pxlRendering.html#.buildComposers">buildComposers</a></li><li data-type='method'><a href="pxlRendering.html#.stepShaderValues">stepShaderValues</a></li><li data-type='method'><a href="pxlRendering.html#.updateCompUniforms">updateCompUniforms</a></li></ul></li><li><a href="pxlUser.html">pxlUser</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">pxlNav/RoomClass.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- --
// --   Base Room Class Object File          --
// --    -- -- -- -- -- -- -- --             --
// --  Written by Kevin Edzenga; 2020-2024   --
// --                                        --
// --  This class is meant to keep your      --
// --    room file cleaner,                  --
// --  All veriables here are accesible      --
// --    from your file.                     --
// --                                        --
// --  To make your own room;                --
// --    Copy the template room folder -     --
// --     ./Source/js/pxlRooms/templateRoom  --
// --    Then read the 'README.md' file      --
// --                                        --
// -- -- -- -- -- -- -- -- -- -- -- -- -- -- --



import {
  Vector2,
  Vector3,
  Object3D,
  Color,
  FogExp2,
  Group,
  RepeatWrapping,
  UniformsUtils,
  UniformsLib
} from "three";
import { pxlPrincipledVert, pxlPrincipledFrag } from "./shaders/objects/PxlPrincipled.js";

import { COLLIDER_TYPE } from "./core/Enums.js";

/**
 * Class representing a Room Environment.
 * @alias pxlRoom RoomEnvironment
 * @class
 * @description Core functionality and base classes
 */
class RoomEnvironment{
  /**
   * Create a Room Environment.
   * @param {string} roomName - The name of the room.
   * @param {string} assetPath - The path to the assets.
   */
  constructor( roomName='pxlRoomEnvironment', assetPath='' ){
    this.roomName=roomName;
    this.pxlOptions=null;
    this.pxlEnums=null;
    this.pxlFile=null;
    this.pxlUtils=null;
    this.pxlTimer=null;
    this.pxlAnim=null;
    this.pxlColliders=null;
    this.pxlDevice=null;
    this.pxlHUD=null;
    this.pxlRendering=null;
    this.pxlEnv=null;
    this.booted=false;
    this.initScene=true;
    this.active=true;
    if( assetPath === "" ){
      assetPath = "./pxlRooms/" + roomName + "/";
    }
    this.assetPath=assetPath+"Assets/";
    this.mobile=false;
    
    this.sceneFile = null;
    this.animFile = null;
    this.animClips = {};
    this.animMixer = null;
    
    // Environment Shader 
    this.spiralizerUniforms = {};
    this.materialList={};
		this.revertColorSpaceList=[];
    this.particleList={};
    
    // Room warp data
    this.camInitPos = null;
    this.camInitLookAt = null;
    this.camThumbPos = new Vector3(0,0,-30);
    this.camThumbLookAt = new Vector3(0,35,-1000);
    this.cameraBooted = false;
    this.cameraPrevPos = new Vector3(0,0,0);
    this.cameraAimTarget = new Object3D(0,0,0);
    this.camHoldWarpPos = true;
    this.defaultCamLocation = "default";
    this.camLocation  =  {};
    
    this.pxlCamFOV = { 'PC':60, 'MOBILE':80 };
    this.pxlCamZoom = 1;
    this.pxlCamAspect = 1;
    this.pxlCamNearClipping = 5;
    this.pxlCamFarClipping = 10000;

    // this.fogColor=new Color(.3,.3,.3);
    this.fogColor = new Color(.01,.02,.05);
    this.fogExp = .0007;
    this.fog = new FogExp2( this.fogColor, this.fogExp);
        
    this.userAvatarGroup = new Group();
    this.packedTextureMaterial = null;
    this.coreTextureMaterial = null;
    this.projectedMaterial = null;
    this.voidMaterial = null;
    this.holoMaterial = null;
    this.aspectRatio = null;
    this.flag = null;
    this.initPos = [];
    this.finalPos = [];
    this.midPos = new Vector3(0,30,-50);

    this.perspectiveInstances = 160;
    
    this.startTime = 0;
    this.runTime = new Vector2(0, 0);
    this.msRunner = null;
    this.camera = null;
    this.autoCamPaths = {};
    this.scene = null;
    this.lightList = {}
    this.geoList = {}
    this.glassGroup = null;
    this.glassList = []
    this.particleList = {};
    this.lodList = [];
    

    this.enableRaycast = false;
    this.hasHoverables=false;
    this.hoverableList=[];
    this.hoverableObj=null;
    
    this.hasClickables=false;
    this.clickableList=[];
    this.clickableObj=null;
    
    
    this.collidersExist=false;
    this.colliderActive=false;
    this.colliderHashMap={};
    this.colliderList= [];
    this.antiColliderActive=false;
    this.antiColliderList= [];
    this.antiColliderTopActive=false;
    this.antiColliderTopList= [];
    
    this.hasPortalExit=false;
    this.portalList={};

    this.hasRoomWarp=false;
    this.roomWarp=[];
    this.warpPortalTexture=null;
    this.warpZoneRenderTarget=null;
        
    this.worldPosMaterial=null;
    this.worldPosRenderTarget=null;
    this.spiralizerPass=null;
    
    this.bloomPreState=false;
        
    this.cloud3dTexture=null;
    this.smoothNoiseTexture=null;
        
    // Helper objects for debug visualizations
    this.hasHelpers = false;
    this.helperObjects = {};

    //%=
    this.currentShader=null;
    //%
  }

  /**
   * Set pxlNav dependencies.
   * @param {Object} pxlNav - The pxlNav object.
   */
  setDependencies( pxlNav ){
    this.pxlOptions = pxlNav.pxlOptions;
    this.pxlEnums = pxlNav.pxlEnums;
    this.pxlRendering = pxlNav.pxlRendering;
    this.pxlEnv = pxlNav;
    this.pxlFile = pxlNav.pxlFile;
    this.pxlAnim = pxlNav.pxlAnim;
    this.pxlTimer = pxlNav.pxlTimer;
    this.pxlUtils = pxlNav.pxlUtils;
    this.pxlDevice = pxlNav.pxlDevice;
    this.pxlHUD = pxlNav.pxlHUD;
    this.pxlColliders = pxlNav.pxlColliders;
    this.mobile = pxlNav.mobile;
    this.msRunner = this.pxlTimer.msRunner;


    this.cloud3dTexture=this.pxlEnv.cloud3dTexture;
    if( this.cloud3dTexture ){
      this.cloud3dTexture.wrapS = RepeatWrapping;
      this.cloud3dTexture.wrapT = RepeatWrapping;
    }

    this.smoothNoiseTexture=this.pxlEnv.softNoiseTexture;
    if( this.smoothNoiseTexture ){
      this.smoothNoiseTexture.wrapS = RepeatWrapping;
      this.smoothNoiseTexture.wrapT = RepeatWrapping;
    }
  }
  
  // -- -- --
  
  /**
   * Get the delta time.
   * @returns {number} The delta time.
   */
  get deltaTime(){
    return this.pxlTimer.deltaTime;
  }

  /**
   * Get the average delta time.
   * @returns {number} The average delta time.
   */
  get avgDeltaTime(){
    return this.pxlTimer.avgDeltaTime;
  }

  /**
   * Get the lerp rate.
   * @param {number} rate - The rate.
   * @returns {number} The lerp rate.
   */
  getLerpRate( rate ){
    return this.pxlTimer.getLerpRate( rate );
  }

  /**
   * Get the average lerp rate.
   * @param {number} rate - The rate.
   * @returns {number} The average lerp rate.
   */
  getLerpAvgRate( rate ){
    return this.pxlTimer.getLerpAvgRate( rate );
  }
  // -- -- --

  /**
   * Initialize the room environment.
   * Ran after core `pxlNav` modules have been loaded and initialized
   *   But before the render composers / post-processing
   */
  init(){
    this.scene.fog=this.fog;
    this.scene.background = this.fogColor ;//pxlEnv.fogColor;
  }

  /**
   * Start the room environment.
   * Run on init room warp; reset room values
   */
  start(){
    if( !this.booted ){
      //this.resetCamera();
    }

    this.pxlRendering.engine.setClearColor(this.fogColor, 0);

    /*this.spiralizerPass.enabled=true;
    this.bloomPreState=this.pxlRendering.roomBloomPass.enabled;  
    this.pxlRendering.roomBloomPass.enabled=false;  */
  }
  
  /**
   * Per-frame render updates.
   */
  step(){
    this.runTime.x=this.msRunner.x;

    // Update helper objects, if they exist
    //this.stepColliderHelper( COLLIDER_TYPE.FLOOR );

    // Update LODs manually with camera position
    /*if( this.lodList.length > 0 ){
      this.lodList.forEach( (lod)=>{
        if( lod.getCurrentLevel()>0 ){
        lod.update( this.camera );
        }
      });
    }*/
    
    //this.pxlRendering.engine.setClearColor(this.pxlEnv.fogColor, 0);
    
    // Render world positions for composer
    //   There must be a better way to get world positions,
    //     The render pass must have an option for this... Or could be added hHmmMMmmm
    /*this.scene.overrideMaterial=this.worldPosMaterial;
    this.pxlRendering.engine.setRenderTarget(this.worldPosRenderTarget);
    this.pxlRendering.engine.clear();
    this.pxlRendering.engine.render( this.scene, this.camera );
    this.scene.overrideMaterial=null;
    this.pxlRendering.engine.setRenderTarget(null);*/
        
  }

  /**
   * Stop the room environment.
   * Ran When leaving the room
   */
  stop(){
    //this.spiralizerPass.enabled=false;
    //this.pxlRendering.roomBloomPass.enabled=this.bloomPreState;
  }
  
  // -- -- --

  /**
   * Handle window resize.
   * @param {number} sW - The width of the window.
   * @param {number} sH - The height of the window.
   */
  resize( sW, sH ){
    /*if(this.worldPosRenderTarget){
      this.worldPosRenderTarget.setSize( sW, sH );
    }
    if(this.spiralizerPass){
      this.spiralizerPass.setSize( sW, sH );
    }*/
  }
  
  /**
   * Set the user height.
   * @param {number} [toHeight=1] - The height to set.
   */
  setUserHeight( toHeight=1 ){
    this.pxlEnv.pxlCamera.setUserHeight( toHeight, this.roomName );
  }

  /**
   * Reset the camera.
   */
  resetCamera(){
    if( (this.camInitPos===null || this.camInitLookAt===null) &amp;&amp; this.pxlOptions.verbose >= this.pxlEnums.VERBOSE_LEVEL.WARN ){
      console.warn("pxlRoomEnvironment: Room Initial Camera Positions not initialized, \n Ensure `this.booted=true` is ran in `build()` or `fbxPostLoad()` \n -&amp;-\n That there is a `Camera` group with `position` &amp; `lookAt` child nulls in your scene file.");
    }
    this.pxlEnv.pxlCamera.setTransform( this.camInitPos, this.camInitLookAt );
    /*if( !this.pxlEnv.pxlOptions["staticCamera"] ){
      this.pxlEnv.pxlCamera.camUpdated = true;
      this.pxlEnv.pxlCamera.hasMoved = true;
      this.pxlEnv.pxlCamera.hasGravity = true;
    }*/
  }
    
  /**
   * Prepare Warp Zone Portal Texture
   */
  prepPortalRender(){
    this.geoList['intro'].visible=false;
    this.geoList['MainRoomWarp'].visible=false;
  }
  /**
   * Cleanup portal render.
   */
  cleanupPortalRender(){
    this.geoList['intro'].visible=true;
    this.geoList['MainRoomWarp'].visible=true;
  }
  /**
   * Set the portal texture.
   * Set the Room Warp Portal plane to display the render from the main room
   * @param {Object} texture - The texture.
   * @param {string|null} [toRoom=null] - The room to set.
   */
  setPortalTexture(texture, toRoom=null){
    this.geoList['MainRoomWarp'].material.map=texture;
  }
    
  /**
   * Apply composer's room pass.
   * @param {Object|null} [roomComposer=null] - The room composer.
   * @returns {Object|null} The shader pass.
   */
  applyRoomPass( roomComposer=null ){
    /*if(roomComposer){
      this.worldPosMaterial=new ShaderMaterial({
        uniforms:{
          camNear: { type:"f", value: 1 },
          camFar: { type:"f", value: 900 } // Measured in the Scene file, 885.61
        },
        vertexShader: worldPositionVert(),
        fragmentShader: worldPositionFrag()
      });
      //this.worldPosMaterial.side=DoubleSide;
      //this.worldPosMaterial.side=FrontSide;
      
      this.spiralizerPass = new ShaderPass(
        new ShaderMaterial( {
          uniforms: {
            tDiffuse: { value: null },
            localPos: { value: this.pxlUtils.loadTexture(this.assetPath+"SpiralizerFadeMap_1k.jpg") },
            worldPos: { value: this.worldPosRenderTarget.texture },
            noiseTexture: { value: this.pxlEnv.cloud3dTexture },
            camMat:{ value:this.camera.matrixWorld },
            marker: { value: new Vector3( -619.01, 67.856, 240.177) },
            time:{ value:this.msRunner },
            screenRes: { value: this.pxlDevice.screenRes },
          },
          vertexShader: cameraCalcVert(),
          fragmentShader: spiralizerPostProcess(),
          defines: {}
        } ), "tDiffuse"
      );
      this.spiralizerPass.enabled=false;
      
      return this.spiralizerPass;
    }*/
  }
  
  /**
   * Get the room name.
   * @returns {string} The room name.
   */
  getName(){
    return this.roomName;
  }

  /**
   * Get artist information.
   * @returns {Object|null} The artist information.
   */
  getArtistInfo(){
    return null;
  }
  
  /**
   * Set the fog color.
   * @param {Object} color - The color.
   */
  setFog( color ){
    // this.geoList["skySemiSphere"].material.uniforms.skyColor.value.x= this.fog.color.r*10.0 ;
    // this.geoList["skySemiSphere"].material.uniforms.skyColor.value.y= this.fog.color.g*10.0 ;
    // this.geoList["skySemiSphere"].material.uniforms.skyColor.value.z= this.fog.color.b*10.0 ;
    // this.geoList["skySemiSphere"].material.uniforms.fogColor.value.r=this.fog.color.r*5;
    // this.geoList["skySemiSphere"].material.uniforms.fogColor.value.g=this.fog.color.g*5;
    // this.geoList["skySemiSphere"].material.uniforms.fogColor.value.b=this.fog.color.b*5;
  }
      
  //%=
  /**
   * Get the geometry shader list.
   * @returns {Object} The shader list.
   */
  getShaderList(){
    let retList={}
    let objList=Object.keys( this.materialList );
    objList.forEach( (k)=>{
      retList[k]=k
    });
    return retList;
  }
  /**
   * Get the currently editing shader.
   * @returns {string} The current shader.
   */
  getCurrentShader(){
    return this.currentShader || Object.keys( this.materialList )[0];
  }
  /**
   * Read the shader from the object.
   * @param {string} [objShader=""] - The shader object.
   * @param {Object|null} [sliderVectorObj=null] - The slider vector object.
   * @returns {Object} The shader material.
   */
  readShader( objShader="", sliderVectorObj=null ){
    if( this.currentShader!=null &amp;&amp; this.materialList[ this.currentShader ].hasOwnProperty('uniforms')){
      if( !sliderVectorObj ){
        sliderVectorObj=new Vector3();
      }
      this.materialList[ this.currentShader ].uniforms.sliders.value=sliderVectorObj;
      this.materialList[ this.currentShader ].needsUpdate=true;
    }
    this.currentShader=objShader;
    return this.materialList[ this.currentShader ];
  }
  /**
   * Set the geometry's material vertex &amp; fragment shaders.
   * @param {Object} unis - The uniforms.
   * @param {string} vert - The vertex shader.
   * @param {string} frag - The fragment shader.
   */
  setShader( unis, vert, frag ){
    if( this.emitterList &amp;&amp; this.emitterList[ this.currentShader ] ){
      if( this.emitterList[ this.currentShader ].Particles.length > 0 ){
        this.emitterList[ this.currentShader ].Particles.forEach( (p)=>{
          let mtl = p.material;
          mtl.vertexShader=vert;
          mtl.fragmentShader=frag;
          mtl.needsUpdate=true;
        });
      }
    }
    
    this.materialList[ this.currentShader ].vertexShader=vert;
    this.materialList[ this.currentShader ].fragmentShader=frag;
    this.materialList[ this.currentShader ].needsUpdate=true;
  }
  //%
  
    
  /**
   * Cast a ray using pxlNav's raycaster.
   * For Three.js' raycaster, please use the Three.js raycaster directly
   * Note - pxlNav's raycaster requires object's are registered,
   *   All object's are pre-processes for faster raycasting
   * @param {boolean} isClick - Whether it is a click.
   * @param {number} mButton - The mouse button.
   */
  castRay( isClick, mButton ){
    if(!this.enableRaycast){
      return;
    }
    if( ( !isClick &amp;&amp; !this.hasHoverables ) || ( isClick &amp;&amp; !this.hasClickables ) ){
      //console.log("No Cickable / Hoverable Objects Found");
      this.mouseRayHits=[];
      return;
    }
    
    let castableObjects = []
    if( !isClick &amp;&amp; this.hasHoverables ) {
      castableObjects = this.hoverableList;
    }else if( isClick &amp;&amp; this.hasClickables ){
      castableObjects = this.clickableList;
    }
    
    var rayHits=[];
    if(castableObjects.length>0){
    
      let mouseScreenSpace=new Vector2( this.pxlDevice.mouseX/this.pxlDevice.sW*2-1, -this.pxlDevice.mouseY/this.pxlDevice.sH*2+1 );
      this.pxlEnv.pxlCamera.objRaycast.setFromCamera(mouseScreenSpace, this.pxlEnv.pxlCamera.camera );
    
      rayHits=this.pxlEnv.pxlCamera.objRaycast.intersectObjects(castableObjects);
    }

    this.mouseRayHits=rayHits;
  }

  // -- -- --

  /**
   * Handle pxlColliders collider hits.
   * @param {Array} colliderList - The list of colliders.
   * @param {number} [colliderType=COLLIDER_TYPE.FLOOR] - The type of collider.
   */
  hitColliders( colliderList=[], colliderType=COLLIDER_TYPE.FLOOR ){
    if( colliderList.length===0 ){
      return;
    }
    // Implement custom-event logic in this function to handle collisions in your room
    /* switch( colliderType ){
      case COLLIDER_TYPE.FLOOR:
        break;
      case COLLIDER_TYPE.WALL:
        break;
      case COLLIDER_TYPE.WALL_TOP:
        break;
      case COLLIDER_TYPE.CEILING:
        break;
      case COLLIDER_TYPE.PORTAL_WARP:
        break;
      case COLLIDER_TYPE.ROOM_WARP:
        break;
      case COLLIDER_TYPE.ITEM:
        break;
      case COLLIDER_TYPE.SCRIPTED:
        break;
      case COLLIDER_TYPE.HOVERABLE:
        break;
      case COLLIDER_TYPE.CLICKABLE:
        break;
      default:
        break;
    } */
  }

  // -- -- --

  /**
   * Check if colliders exist.
   * @returns {boolean} Whether colliders exist.
   */
  hasColliders(){
    return this.collidersExist
  }

  /**
   * Check if a specific type of collider exists.
   * @param {number} [colliderType=COLLIDER_TYPE.FLOOR] - The type of collider.
   * @returns {boolean} Whether the specific type of collider exists.
   */
  hasColliderType( colliderType=COLLIDER_TYPE.FLOOR ){
    let hasCollidersOfType = false;
    if( !this.hasColliders() ){
      return hasCollidersOfType;
    }

    switch( colliderType ){
      case COLLIDER_TYPE.FLOOR:
        hasCollidersOfType = this.colliderActive;
        break;
      case COLLIDER_TYPE.WALL:
        hasCollidersOfType = this.antiColliderActive;
        break;
      case COLLIDER_TYPE.WALL_TOP:
        hasCollidersOfType = this.antiColliderTopActive;
        break;
      case COLLIDER_TYPE.CEILING:
        // Not implemented yet
        break;
      case COLLIDER_TYPE.PORTAL_WARP:
        hasCollidersOfType = this.hasPortalExit;
        break;
      case COLLIDER_TYPE.ROOM_WARP:
        hasCollidersOfType = this.hasRoomWarp;
        break;
      case COLLIDER_TYPE.ITEM:
        // Not implemented yet
        break;
      case COLLIDER_TYPE.SCRIPTED:
        // Not implemented yet
        break;
      case COLLIDER_TYPE.HOVERABLE:
        hasCollidersOfType = this.hasHoverables;
        break;
      case COLLIDER_TYPE.CLICKABLE:
        hasCollidersOfType = this.hasClickables;
        break;
      default:
        hasCollidersOfType = false;
        break;
    }

    return hasCollidersOfType;
  }

  // -- -- --

  /**
   * Get the colliders of a specific type.
   * @param {number} [colliderType=COLLIDER_TYPE.FLOOR] - The type of collider.
   * @returns {Array} The list of colliders.
   */
  getColliders( colliderType=COLLIDER_TYPE.FLOOR ){
    let forHashing = [];
    if( !this.hasColliders() ){
      return forHashing;
    }

    // Kick out if the collider type is not active
    //  ( No colliders of the given type exist )
    if( colliderType===COLLIDER_TYPE.WALL &amp;&amp; !this.antiColliderActive ){
      forHashing = this.antiColliderList;
      return forHashing;
    }else if( colliderType===COLLIDER_TYPE.WALL_TOP &amp;&amp; !this.antiColliderTopActive ){
      forHashing = this.antiColliderTopList;
      return forHashing;
    }else if( colliderType===COLLIDER_TYPE.PORTAL_WARP &amp;&amp; !this.hasPortalExit ){
      forHashing = this.portalList;
      return forHashing;
    }else if( colliderType===COLLIDER_TYPE.ROOM_WARP &amp;&amp; !this.hasRoomWarp ){
      forHashing = this.roomWarp;
      return forHashing;
    }else if( colliderType===COLLIDER_TYPE.HOVERABLE &amp;&amp; !this.hasHoverables ){
      forHashing = this.hoverableList;
      return forHashing;
    }else if( colliderType===COLLIDER_TYPE.CLICKABLE &amp;&amp; !this.hasClickables ){
      forHashing = this.clickableList;
      return forHashing;
    }
    
    // TODO : Quadrant hashing for colliders should be removed from pxlNav support, with new grid hashing system implemented
    // TODO : Maya tools and FBX requirements needs updating for the new collider system
    switch( colliderType ){
      case COLLIDER_TYPE.FLOOR:
        forHashing = [ ...this.colliderList ];
        break;
      case COLLIDER_TYPE.WALL:
        forHashing = [ ...this.colliderList ];
        break;
      case COLLIDER_TYPE.WALL_TOP:
        forHashing = [ ...this.antiColliderTopList ];
        break;
      case COLLIDER_TYPE.CEILING:
        // Not implemented yet
        break;
      case COLLIDER_TYPE.PORTAL_WARP:
        forHashing = this.portalList;
        break;
      case COLLIDER_TYPE.ROOM_WARP:
        forHashing = this.roomWarp;
        break;
      case COLLIDER_TYPE.ITEM:
        // Not implemented yet
        break;
      case COLLIDER_TYPE.SCRIPTED:
        // Not implemented yet
        break;
      default:
        break;
    }

    //forHashing = this.colliderHashMap;
    return forHashing;
  }

  // -- -- --

  /**
   * Add a visual collider helper.
   * @param {number} [colliderType=COLLIDER_TYPE.FLOOR] - The type of collider.
   * @example
   * // To add a floor collider helper
   * //   To visualize collider triangles in blue &amp; green
   * // Run these helper functions in your rooms `build()` &amp; `step()`-
   * build(){
   *  this.addColliderHelper( COLLIDER_TYPE.FLOOR );
   * }
   * 
   * step(){
   *  this.stepColliderHelper( COLLIDER_TYPE.FLOOR );
   * }
   */
  addColliderHelper( colliderType=COLLIDER_TYPE.FLOOR ){
    if( !this.hasColliders() ){
      return;
    }
    if( !this.helperObjects.hasOwnProperty('colliders') ){
      this.helperObjects['colliders'] = {};
      this.helperObjects['colliders'][colliderType] = null;
    }else if( !this.helperObjects['colliders'].hasOwnProperty(colliderType) ){
      this.helperObjects['colliders'][colliderType] = null;
    }

    // This is only used to easierly reveal the helper objects to the pxlRoom
    //   This is only for debugging purposes
    this.helperObjects['colliders'][colliderType] = this.pxlColliders.buildHelper( this, colliderType );

    if( this.helperObjects['colliders'][colliderType] ){
      this.scene.add( this.helperObjects['colliders'][colliderType] );
      this.hasHelpers = true;
    }
  }

  /**
   * Step the collider helper.
   * 
   * Not required, as the helper's step function isn't fully implemented yet.
   * @param {number} [colliderType=COLLIDER_TYPE.FLOOR] - The type of collider.
   * @example
   * // To add a floor collider helper
   * //   To visualize collider triangles in blue &amp; green
   * // Run these helper functions in your rooms `build()` &amp; `step()`-
   * build(){
   *  this.addColliderHelper( COLLIDER_TYPE.FLOOR );
   * }
   * 
   * step(){
   *  this.stepColliderHelper( COLLIDER_TYPE.FLOOR );
   * }
   */
  stepColliderHelper( colliderType=COLLIDER_TYPE.FLOOR ){
    if( !this.hasHelpers ||
        !this.hasColliders() ||
        !this.helperObjects.hasOwnProperty('colliders') ||
        !this.helperObjects['colliders'].hasOwnProperty(colliderType) ){
      return;
    }

    this.helperObjects['colliders'][colliderType].stepHelper( this, colliderType );
  }


  // -- -- --
    
  /**
   * Move the camera to a specific position.
   * @param {string|null} [positionName=null] - The name of the position.
   */
  toCameraPos( positionName = null ){
    if( positionName===null ){
      positionName = this.defaultCamLocation;
    }
    positionName = positionName.toLowerCase();

    if( this.cameraBooted &amp;&amp; this.camLocation.hasOwnProperty( positionName ) ){
      
      let posName = this.mobile?"positionmobile":"position";
      let lookAtName = this.mobile?"lookatmobile":"lookat";
      let pos=this.camLocation[ positionName ][ posName ];
      let lookAt=this.camLocation[ positionName ][ lookAtName ];
      if( !lookAt ){
        lookAt=new Vector3(0,0,1);
        lookAt.addVectors( pos, lookAt );
      }

      this.pxlEnv.pxlCamera.setTransform( this.camLocation[positionName][posName], this.camLocation[positionName][lookAtName] );
      this.setUserHeight( this.camInitPos.y );
    }
  }
    
  /**
   * Ran after the room's FBX loads &amp; processes.
   */
  fbxPostLoad(){
    
    // Let pxlNav know the room is ready
    this.booted=true;

    // Force Camera to init position with optional init look at
    this.toCameraPos( this.defaultCamLocation );

    // Find Point light count for adjusted shadowing
    let pointLightCount = 0;
    if( this.lightList.hasOwnProperty("PointLight") ){
      pointLightCount = this.lightList.PointLight.length;
    }
    
    
    
    /*var ambientLight = new AmbientLight( 0x303030 ); // soft white light
    //this.lightList.push( ambientLight );
    this.scene.add( ambientLight );*/
    
    let lightTypeList = Object.keys( this.lightList );
    if(lightTypeList.length>0){
      lightTypeList.forEach( (type)=>{
        this.lightList[type].forEach( (light)=>{
          if( type==="DirectionalLight" ){ 
            light.castShadow=false;
          }else if( type==="PointLight" ){ 
            if( light.castShadow){
              light.shadow.radius = 5;
              light.shadow.receiveShadow = true;
              light.shadow.mapSize.width = 512; // default
              light.shadow.mapSize.height = 512; // default
              light.shadow.camera.near = 0.5; // default
              light.shadow.camera.far = 35; // default
              light.shadow.bias = .025; // default
              light.shadow.radius = 5; // default
            }
          }
        });
      });
    }
    
    
    if( this.shaderGeoList ) {
      for( const x in this.shaderGeoList){
        let curObj = this.shaderGeoList[x];
        if( curObj.userData &amp;&amp; curObj.userData.Shader === "pxlPrincipled"){
          
          let shaderUniforms = UniformsUtils.merge(
              [
                UniformsLib[ "common" ],
                UniformsLib[ "lights" ],
                UniformsLib[ "shadowmap" ],
                {
                  'dTexture' : { type:'t', value: null },
                  'noiseTexture' : { type:'t', value: null },
                  'detailTexture' : { type:'t', value: null },
                  'cdMult' : { type:'f', value: 1 },
                  'fogColor' : { type: "c", value: this.scene.fog.color },
                }
              ]
          )
          var defines = {};
          defines[ "USE_MAP" ] = "";
          
          let ShaderParms = {};
          let useLights = true
          let useShadows = curObj.userData.castShadow === true || curObj.userData.receiveShadow === true
          let useFog = true;
          
          let useColor = false;
          if( !curObj.material.map ){
            useColor = curObj.material.color.clone();
          }
          
          // Add ShaderParms support
          if( curObj.userData.ShaderParms &amp;&amp; curObj.userData.ShaderParms !== "" ){
            ShaderParms = JSON.parse(curObj.userData.ShaderParms);
          }
          
          let mat=this.pxlFile.pxlShaderBuilder(
              shaderUniforms,
              pxlPrincipledVert( useShadows ),
              pxlPrincipledFrag( ShaderParms, useColor, useFog, useLights, useShadows, pointLightCount ),
              defines
            );
          //mat.side=FrontSide;
          mat.transparent= false;
          mat.lights= true;
          if(!useColor){
            mat.uniforms.dTexture.value = curObj.material.map;
          }
          mat.uniforms.noiseTexture.value = this.cloud3dTexture;
          mat.uniforms.detailTexture.value = this.pxlEnv.detailNoiseTexture;
              
          curObj.material=mat;
          this.materialList[ curObj.name ] = mat;
        }
      }
    }
    
    
    
    
    
    
    /*
    let envGroundUniforms = UniformsUtils.merge(
            [
              UniformsLib[ "common" ],
              UniformsLib[ "lights" ],
              UniformsLib[ "shadowmap" ],
              {
                'diffuse' : { type:'t', value: null },
                'dirtDiffuse' : { type:'t', value: null },
                'mult': { type:'f', value:1 },
                'fogColor': { type:'c', value: null },
                'noiseTexture' : { type:'t', value: null },
                'uniformNoise' : { type:'t', value: null },
                'crossNoise' : { type:'t', value: null },
              }
            ]
        );
    let textureOptions = {
        "wrapS" : RepeatWrapping,
        "wrapT" : RepeatWrapping,
    };
    envGroundUniforms.fogColor.value = this.scene.fog.color;
    envGroundUniforms.diffuse.value = this.pxlUtils.loadTexture( this.assetPath+"EnvGround_Diffuse.jpg" );
    envGroundUniforms.dirtDiffuse.value = this.pxlUtils.loadTexture( this.assetPath+"Dirt_Diffuse.jpg" );
    envGroundUniforms.noiseTexture.value = this.cloud3dTexture;
    envGroundUniforms.uniformNoise.value = this.pxlUtils.loadTexture( this.assetPath+"Noise_UniformWebbing.jpg" );
    envGroundUniforms.crossNoise.value = this.pxlUtils.loadTexture( this.assetPath+"Noise_NCross.jpg" );
    
    let environmentGroundMat=this.pxlFile.pxlShaderBuilder( envGroundUniforms, envGroundVert(), envGroundFrag(1) );
    environmentGroundMat.lights= true;
    
    envGroundUniforms.uniformNoise.value.wrapS = RepeatWrapping;
    envGroundUniforms.uniformNoise.value.wrapT = RepeatWrapping;
    envGroundUniforms.crossNoise.value.wrapS = RepeatWrapping;
    envGroundUniforms.crossNoise.value.wrapT = RepeatWrapping;
    envGroundUniforms.dirtDiffuse.value.wrapS = RepeatWrapping;
    envGroundUniforms.dirtDiffuse.value.wrapT = RepeatWrapping;
    
    this.materialList[ "EnvironmentGround_Geo" ]=environmentGroundMat;
    */
    
    
    
  }
  
  /**
   * Ran after the room's animation FBX files load &amp; process.
   * @param {string} animKey - The animation key.
   * @param {Object} animMixers - The animation mixers.
   */
  animPostLoad( animKey, animMixers ){
    if( this.pxlAnim.hasClip( animKey, this.animInitCycle ) ){
      let animMixer = this.pxlAnim.getMixer( animKey );
      this.animMixer = animMixer;
      
      this.pxlAnim.playClip( animKey, this.animInitCycle );
    }else{
      let fallback = this.pxlAnim.getFallbackCycle( animKey );
      this.animInitCycle = fallback;
      this.log("No animation cycle '"+this.animInitCycle+"' found; Using '"+fallback+"' instead");
    }
  }
  
// -- -- -- -- -- -- -- -- -- -- -- -- -- //

  /**
   * Build the scene and assets.
   */
  build(){
    // Attempt to build the FBX if it exists
    if( !this.sceneFile ){
      return;
    }
    //this.pxlFile.loadRoomFBX( this ) 
  }

// -- -- -- -- -- -- -- -- -- -- -- -- -- //

  /**
   * Handle incoming messages.
   * @param {string} msgType - The type of message.
   * @param {Object} msgValue - The value of the message.
   */
//   Custom implementation of HTML/GUI in conjunction with pxlNav
//     Lets get some incoming messages to trigger some stuffs!
  onMessage( msgType, msgValue ){
    console.log("Room : "+this.roomName+" - Message Received: "+msgType);
    console.log("Message : "+msgValue);
    msgType = msgType.toLowerCase();
    switch( msgType ){
      case "roomwarp":
        this.roomWarp=msgValue;
        break;
        default:
      case "roommessage":
        console.log( "-- Message Type Not Recognized -- " );
        console.log( "Room : "+this.roomName );
        console.log( "Message Received: "+msgType );
        console.log( "Message : "+msgValue );
        break;
    }
  }
}



export { RoomEnvironment };</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.4</a> on Sun Sep 14 2025 23:24:32 GMT-0400 (Eastern Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



    <script src="https://unpkg.com/mermaid/dist/mermaid.js"></script>
    
    <script src="docs-init.js"></script>
    
</body>
</html>
